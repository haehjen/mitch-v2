<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MITCH Interface</title>

  <style>
    :root{
      --chat-blue: rgba(0,100,255,0.2);
      --z-chat: 100; --z-site: 60; --z-log: 40; --z-overlay: 120; /* above 3D canvas */
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:#000;color:#0ff;font-family:monospace;overflow:hidden}

    /* Three.js canvas */
    body > canvas { position:fixed; inset:0; z-index:1; display:block; }

    .chrome{border:1px solid var(--chat-blue);box-shadow:0 0 12px var(--chat-blue);border-radius:16px;background:#000}

    #chat-container{position:absolute;bottom:2rem;left:50%;transform:translateX(-50%);
      width:90%;max-width:720px;background:rgba(30,30,30,.95);padding:.5rem 1rem;border-radius:16px;
      box-shadow:0 0 12px var(--chat-blue);border:1px solid var(--chat-blue);z-index:var(--z-chat)}
    #chat-log{color:#0ff;font-size:1rem;line-height:1.4rem;white-space:pre-wrap;margin-bottom:.5rem;max-height:200px;overflow-y:auto}
    #chat-input{width:100%;padding:.4rem;font-size:1rem;border-radius:8px;border:none;outline:none;background:#111;color:#0ff}

    #workspace-frame{position:absolute;top:24px;right:24px;width:354px;height:260px;z-index:var(--z-site)}
    #workspace-frame.chrome{background:#000}

    #log-console{position:absolute;right:24px;bottom:24px;width:520px;height:300px;color:#0ff;font-size:.75rem;
      padding:.5rem;overflow-y:auto;z-index:var(--z-log);background:rgba(0,0,0,.6)}
    #log-console.chrome{background:rgba(0,0,0,.6)}

    /* Flight frames on top of the scene */
    #flight-frames{position:fixed;inset:0;z-index:var(--z-overlay);pointer-events:none}
    .flight-frame{position:absolute;overflow:hidden}
    .flight-frame.chrome{border-radius:16px}
    #uk-frame{top:24px;left:24px;width:360px;height:420px}
    #ne-frame{top:24px;left:408px;width:720px;height:300px}

    .frame-title{position:absolute;top:6px;left:8px;font:600 12px/1.2 ui-sans-serif,system-ui,Segoe UI,sans-serif;color:#a0b4c8;pointer-events:none;text-shadow:0 1px 3px rgba(0,0,0,.6)}

    /* Make sure the canvas sits above the map image */
    .map-img{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;filter:contrast(1.05) saturate(.95);z-index:0}
    .map-layer{position:absolute;inset:0;width:100%;height:100%;z-index:1}
    /* allow clicks for calibration */
    #uk-canvas{pointer-events:auto}
    #ne-canvas{pointer-events:auto}
  </style>
</head>
<body>
  <div id="flight-frames">
    <div id="uk-frame" class="flight-frame chrome">
      <div class="frame-title">UK Air Picture</div>
      <img id="uk-map" class="map-img" src="/static/maps/uk-sat.png" alt="UK map" loading="eager" decoding="async"/>
      <canvas id="uk-canvas" class="map-layer"></canvas>
    </div>
    <div id="ne-frame" class="flight-frame chrome">
      <div class="frame-title">North East (approx)</div>
      <img id="ne-map" class="map-img" src="/static/maps/north-east-sat.png" alt="NE map" loading="eager" decoding="async"/>
      <canvas id="ne-canvas" class="map-layer"></canvas>
    </div>
  </div>

  <div id="chat-container" class="chrome">
    <div id="chat-log"></div>
    <div style="display:flex;gap:.5rem">
      <button id="upload-btn" title="Upload file" style="background:none;border:none;color:inherit;font-size:2rem;cursor:pointer;padding:0;line-height:1;display:flex;align-items:center;justify-content:center">+</button>
      <input type="file" id="file-upload" style="display:none" accept=".jpg,.jpeg,.png,.pdf,.html,.txt">
      <input id="chat-input" type="text" placeholder="Say something to Echo..." style="flex:1">
    </div>
  </div>

  <iframe id="workspace-frame" class="chrome" src="https://andymitchell.online" frameborder="0"></iframe>
  <div id="log-console" class="chrome"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <script src="/OBJLoader.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script>
    /* ===== Chat plumbing (guarded) ===== */
    (function(){
      var chatLog=document.getElementById('chat-log');
      var chatInput=document.getElementById('chat-input');
      var MAX_LINES=10;

      function appendMessage(sender,message){
        if(!chatLog) return;
        var entry=document.createElement('div');
        entry.textContent=(sender?sender:'')+': '+(message||'');
        entry.style.color=(sender==='YOU')?'#aaa':'#0ff';
        chatLog.appendChild(entry);
        while(chatLog.children.length>MAX_LINES){ chatLog.removeChild(chatLog.firstChild); }
        chatLog.scrollTop=chatLog.scrollHeight;
      }
      window.appendMessage=appendMessage; // reuse in uploader

      function checkForMitchUpdates(){
        fetch('/get_response').then(function(res){return res.json();})
          .then(function(data){
            if(data && data.text) appendMessage('Echo', data.text);
            if(data && data.audio){ new Audio('/audio/'+data.audio).play(); }
          }).catch(function(){});
      }

      function sendUserInput(text){
        if(!text || !text.trim()) return;
        appendMessage('YOU', text);
        fetch('/listen',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({text:text})});
      }

      if(chatInput){
        chatInput.addEventListener('keydown',function(e){
          if(e.key==='Enter'){
            var t=e.target.value; e.target.value='';
            sendUserInput(t);
          }
        });
      }
      setInterval(checkForMitchUpdates,2000);
    })();

    /* ===== Upload button (no optional chaining) ===== */
    window.addEventListener('DOMContentLoaded', function(){
      var uploadBtn=document.getElementById('upload-btn');
      var fileInput=document.getElementById('file-upload');
      if(uploadBtn && !uploadBtn.dataset.bound){
        uploadBtn.addEventListener('click', function(){ if(fileInput) fileInput.click(); });
        uploadBtn.dataset.bound='1';
      }
      if(fileInput && !fileInput.dataset.bound){
        fileInput.addEventListener('change', function(e){
          var f=(e && e.target && e.target.files && e.target.files[0]) ? e.target.files[0] : null;
          if(!f) return;
          if(window.appendMessage) window.appendMessage('YOU','Uploading: '+f.name);
          var form=new FormData(); form.append('file', f, f.name);
          fetch('/upload',{method:'POST',body:form})
            .then(function(res){return res.json();})
            .then(function(data){
              if(window.appendMessage) window.appendMessage('Echo',(data && data.message)?data.message:('Received '+f.name));
            }).catch(function(){
              if(window.appendMessage) window.appendMessage('Echo','Upload failed.');
            }).finally(function(){ fileInput.value=''; });
        });
        fileInput.dataset.bound='1';
      }
    });

    /* ===== Flight overlay drawing (decluttered + robust JSON + pins) ===== */
    (function(){
      var UK_BOUNDS={latMin:49.8,latMax:60.9,lonMin:-8.7,lonMax:2.1};
      var NE_BOUNDS={latMin:53.8,latMax:56.9,lonMin:-3.6,lonMax:-0.3};
      var PINS=[];               // {lat,lon,label,description,ts}
      var lastUK=[], lastNE=[];  // cache latest contacts for redraws
      var lastBase=null;

      function safeParse(raw){
        try { return JSON.parse(raw); }
        catch(e){
          var i = raw.lastIndexOf('{');
          if(i >= 0){ try { return JSON.parse(raw.slice(i)); } catch(_) {} }
          return null;
        }
      }

      function ensureCanvasSize(canvas){
        var r = canvas.getBoundingClientRect();
        var dpr = window.devicePixelRatio || 1;
        var W = Math.max(1, Math.floor(r.width));
        var H = Math.max(1, Math.floor(r.height));
        if(canvas.width !== W*dpr || canvas.height !== H*dpr){
          canvas.width = W*dpr; canvas.height = H*dpr;
        }
        var ctx = canvas.getContext('2d');
        if(ctx) ctx.setTransform(dpr,0,0,dpr,0,0);
        return { ctx, width: W, height: H };
      }

      // Web Mercator helpers (better matches satellite tiles)
      function mercY(lat){
        var rad = lat * Math.PI / 180;
        return Math.log(Math.tan((Math.PI/4) + (rad/2)));
      }

      // Given image element and container size, compute effective bounds after CSS object-fit:cover crop
      function effectiveBounds(baseBounds, imgEl, w, h){
        var B = Object.assign({}, baseBounds);
        if(!imgEl || !imgEl.naturalWidth || !imgEl.naturalHeight || !w || !h){
          // fall back: use base, with mercator Y for lat range
          B._yMin = mercY(B.latMin);
          B._yMax = mercY(B.latMax);
          return B;
        }

        var iw = imgEl.naturalWidth, ih = imgEl.naturalHeight;
        var scale = Math.max(w/iw, h/ih);
        var dispW = iw*scale, dispH = ih*scale;
        var fracCropX = Math.max(0, (dispW - w)/dispW); // total cropped fraction (both sides)
        var fracCropY = Math.max(0, (dispH - h)/dispH);
        var leftFrac = fracCropX/2, rightFrac = fracCropX/2;
        var topFrac  = fracCropY/2, bottomFrac = fracCropY/2;

        // Lon linear, Lat via Mercator space
        var lonRange = B.lonMax - B.lonMin;
        var yMin = mercY(B.latMin), yMax = mercY(B.latMax);
        var yRange = yMax - yMin;

        var eff = {
          lonMin: B.lonMin + lonRange*leftFrac,
          lonMax: B.lonMax - lonRange*rightFrac,
          _yMin:  yMin + yRange*topFrac,
          _yMax:  yMax - yRange*bottomFrac
        };
        return eff;
      }

      function drawBase(ctx, effBounds, base, w, h, calKey){
        if(!base) return;
        // Use calibration if available and requested, otherwise fall back to effective bounds mapping
        var CAL=null; if (calKey) { try { CAL = JSON.parse(localStorage.getItem(calKey)||'null'); } catch(_) { CAL=null; } }
        var px, py;
        if (CAL && typeof CAL.axn==='number'){
          var xN = CAL.axn*base.lon + CAL.bxn;
          var yN = CAL.ayn*mercY(base.lat) + CAL.byn;
          px = xN*w; py = yN*h;
        } else {
          px = ((base.lon - effBounds.lonMin)/(effBounds.lonMax - effBounds.lonMin))*w;
          py = (1 - (mercY(base.lat) - effBounds._yMin)/(effBounds._yMax - effBounds._yMin))*h;
        }
        var p = {x:px, y:py};
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.strokeStyle = '#00E5FF';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0,7,0,Math.PI*2); ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-10,0); ctx.lineTo(-3,0); ctx.moveTo(3,0); ctx.lineTo(10,0);
        ctx.moveTo(0,-10); ctx.lineTo(0,-3); ctx.moveTo(0,3); ctx.lineTo(0,10);
        ctx.stroke();
        ctx.restore();

        var label = base.label || 'MITCHcore';
        ctx.font = '600 11px ui-sans-serif,system-ui,Segoe UI';
        var pad=6, hBox=18, m=ctx.measureText(label);
        var bx=Math.min(Math.max(p.x+12,0), w-(m.width+pad*2));
        var by=Math.min(Math.max(p.y-20,0), h-hBox);
        ctx.fillStyle='rgba(5,15,25,0.85)';
        ctx.fillRect(bx,by,m.width+pad*2,hBox);
        ctx.fillStyle='#76FFF1';
        ctx.fillText(label,bx+pad,by+13);
      }

      function drawContacts(canvas, imgEl, bounds, contacts, base, opts, pins){
        if(!canvas || !bounds) return;
        contacts = Array.isArray(contacts) ? contacts : [];
        opts = opts || {};
        pins = Array.isArray(pins) ? pins : [];
        var showCivDots = ('showCivDots' in opts)?opts.showCivDots:true;
        var labelCiv    = ('labelCiv'    in opts)?opts.labelCiv:false;
        var labelMil    = ('labelMil'    in opts)?opts.labelMil:true;
        var maxLabels   = ('maxLabels'   in opts)?opts.maxLabels:60;
        var grid        = ('grid'        in opts)?opts.grid:56;
        var showRefs    = !!opts.refs; // draw reference city dots for debugging

        var sz = ensureCanvasSize(canvas);
        var ctx=sz.ctx, W=sz.width, H=sz.height;
        if(!ctx) return;
        ctx.clearRect(0,0,W,H);

        var EB = effectiveBounds(bounds, imgEl, W, H);
        var isUK = (bounds === UK_BOUNDS);
        var isNE = (bounds === NE_BOUNDS);

        // Optional simple calibration for panel: x = axn*lon + bxn; y = ayn*mercY(lat) + byn (normalized coords)
        var CAL = null; var calKey = null;
        if (isUK){ calKey = 'UK_CALN'; }
        else if (isNE){ calKey = 'NE_CALN'; }
        if (calKey){ try { CAL = JSON.parse(localStorage.getItem(calKey)||'null'); } catch(_) { CAL=null; } }

        function toPx(lat,lon){
          if (CAL && typeof CAL.axn==='number'){
            var my = mercY(lat);
            var xN = CAL.axn*lon + CAL.bxn;
            var yN = CAL.ayn*my  + CAL.byn;
            return { x: xN*W, y: yN*H };
          } else {
            return {
              x: ((lon-EB.lonMin)/(EB.lonMax-EB.lonMin))*W,
              y: (1 - (mercY(lat)-EB._yMin)/(EB._yMax-EB._yMin))*H
            };
          }
        }

        // Aircraft glyphs
        for(var i=0;i<contacts.length;i++){
          var c=contacts[i]; if(!c) continue;
          var p=toPx(c.lat,c.lon);
          var isMil=(c.kind==='mil');
          ctx.save();
          if(isMil){
            ctx.translate(p.x,p.y);
            ctx.rotate(((c.heading||0)*Math.PI)/180);
            ctx.fillStyle='rgba(255,168,76,0.95)';
            ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(7,8); ctx.lineTo(-7,8); ctx.closePath(); ctx.fill();
          }else if(showCivDots){
            ctx.fillStyle='rgba(118,255,241,0.95)';
            ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill();
          }
          ctx.restore();
        }

        // Labels (declutter)
        var seen={}, placed=[], labels=0;
        function overlaps(a,b){ return !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y); }
        ctx.font='600 11px ui-sans-serif,system-ui,Segoe UI';

        for(var j=0;j<contacts.length;j++){
          var c2=contacts[j]; if(!c2) continue;
          var isMil2=(c2.kind==='mil');
          var want = (isMil2 && labelMil) || (!isMil2 && labelCiv);
          if(!want) continue; if(labels>=maxLabels) break;

          var pt=toPx(c2.lat,c2.lon);
          var cellKey= (Math.floor(pt.x/grid)+':'+Math.floor(pt.y/grid));
          if(seen[cellKey]) continue; seen[cellKey]=1;

          var label=(c2.label || c2.callsign || 'UNK');
          var padX=6, hBox=18, m=ctx.measureText(label);
          var bx=Math.min(Math.max(pt.x+8,0), W-(m.width+padX*2));
          var by=Math.min(Math.max(pt.y-18,0), H-hBox);
          var box={x:bx,y:by,w:m.width+padX*2,h:hBox};

          var collide=false;
          for(var k=0;k<placed.length;k++){ if(overlaps(box,placed[k])){ collide=true; break; } }
          if(collide) continue;

          ctx.fillStyle='rgba(12,18,24,0.9)';
          ctx.fillRect(box.x,box.y,box.w,box.h);
          ctx.fillStyle=isMil2?'#FFD1A6':'#B2F9FF';
          ctx.fillText(label, box.x+padX, box.y+13);

          placed.push(box); labels++;
        }

        // Base marker
        var calKey = (bounds === UK_BOUNDS) ? 'UK_CALN' : ((bounds === NE_BOUNDS) ? 'NE_CALN' : null);
        drawBase(ctx, EB, base, W, H, calKey);

        // Pins (on top)
        if(pins.length){
          ctx.save();
          for(var p=0;p<pins.length;p++){
            var pin = pins[p]; if(!pin) continue;
            if(typeof pin.lat!== 'number' || typeof pin.lon !== 'number') continue;
            // skip pins outside of this bounds
            if(!CAL){
              if(pin.lon < EB.lonMin || pin.lon > EB.lonMax) continue;
              var my = mercY(pin.lat);
              if(my < EB._yMin || my > EB._yMax) continue;
            }
            var px = toPx(pin.lat, pin.lon);

            // glow ring + dot
            ctx.beginPath();
            ctx.strokeStyle='rgba(255,80,100,0.95)';
            ctx.lineWidth=2;
            ctx.arc(px.x, px.y, 7, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle='rgba(255,120,140,0.95)';
            ctx.beginPath(); ctx.arc(px.x, px.y, 3, 0, Math.PI*2); ctx.fill();

            // label if available
            var lbl = pin.label || '';
            if(lbl){
              ctx.font='600 11px ui-sans-serif,system-ui,Segoe UI';
              var pad=6, hBox=18, m=ctx.measureText(lbl);
              var bx=Math.min(Math.max(px.x+8,0), W-(m.width+pad*2));
              var by=Math.min(Math.max(px.y-18,0), H-hBox);
              ctx.fillStyle='rgba(24,8,10,0.9)';
              ctx.fillRect(bx,by,m.width+pad*2,hBox);
              ctx.fillStyle='#FFC1C9';
              ctx.fillText(lbl, bx+pad, by+13);
            }
          }
          ctx.restore();
        }

        // Reference markers (debugging alignment)
        if(showRefs){
          var refs = [];
          if (isUK){
            refs = [
              {name:'London',  lat:51.5074, lon:-0.1278},
              {name:'Glasgow', lat:55.8642, lon:-4.2518}
            ];
          } else if (isNE){
            // Choose two well-separated points within NE panel
            refs = [
              {name:'Newcastle', lat:54.9733, lon:-1.6139},
              {name:'Whitby',    lat:54.4863, lon:-0.6132}
            ];
          }
          ctx.save();
          for(var r=0;r<refs.length;r++){
            var R=refs[r];
            // skip if outside eff bounds
            if(!CAL){
              if(R.lon < EB.lonMin || R.lon > EB.lonMax) continue;
              var myR = mercY(R.lat);
              if(myR < EB._yMin || myR > EB._yMax) continue;
            }
            var q = toPx(R.lat, R.lon);
            // solid green dot with thin outline
            ctx.fillStyle='#00FF66';
            ctx.strokeStyle='rgba(0,0,0,0.6)';
            ctx.lineWidth=1.5;
            ctx.beginPath(); ctx.arc(q.x, q.y, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            // small label
            ctx.font='600 11px ui-sans-serif,system-ui,Segoe UI';
            ctx.fillStyle='#A6FFC9';
            ctx.fillText(R.name, Math.min(q.x+6, W-40), Math.max(q.y-6, 12));
          }
          ctx.restore();
        }
      }

      function fetchContacts(){
        fetch('/static/flight_contacts.json?ts='+Date.now(),{cache:'no-store'})
          .then(function(res){ if(!res.ok) throw new Error('fetch failed'); return res.text(); })
          .then(function(raw){
            var payload = safeParse(raw) || {};
            var uk = Array.isArray(payload.uk)?payload.uk:[];
            var ne = Array.isArray(payload.ne)?payload.ne:[];
            var base = payload.base || null;

            // cache for redraws (e.g., when new pins arrive)
            lastUK = uk; lastNE = ne; lastBase = base;

            drawContacts(document.getElementById('uk-canvas'), document.getElementById('uk-map'), UK_BOUNDS, uk, base,
              {showCivDots:true,labelCiv:false,labelMil:true,maxLabels:70,grid:56,refs:true}, PINS);
            drawContacts(document.getElementById('ne-canvas'), document.getElementById('ne-map'), NE_BOUNDS, ne, base,
              {showCivDots:true,labelCiv:true,labelMil:true,maxLabels:40,grid:44,refs:true}, PINS);

            console.debug('[flights]', {uk: uk.length, ne: ne.length, updated: payload.updated});
          })
          .catch(function(err){ console.debug('fetchContacts failed', err && err.message); });
      }

      window.addEventListener('DOMContentLoaded', function(){
        fetchContacts();
        setInterval(fetchContacts,15000);
        window.addEventListener('resize', fetchContacts);
      });

      // Bind to socket for incoming pins and trigger redraws
      function bindPinSocket(){
        var sock = window.socket || (window.io && window.io());
        if(!sock){ setTimeout(bindPinSocket, 400); return; }
        try { console.info('[orb] pin overlay binding to socket'); } catch(_) {}
        sock.on('EMIT_MAP_PIN', function(data){
          if(!data || typeof data.lat !== 'number' || typeof data.lon !== 'number') return;
          data.ts = Date.now();
          // dedupe by label+coords to avoid infinite growth
          for(var i=0;i<PINS.length;i++){
            var p=PINS[i];
            if(p && p.label===data.label && p.lat===data.lat && p.lon===data.lon){ PINS[i]=data; redraw(); return; }
          }
          PINS.push(data); redraw();
        });
      }

      function redraw(){
        try { console.debug('[orb] redraw overlays. pins:', PINS.length); } catch(_) {}
        drawContacts(document.getElementById('uk-canvas'), document.getElementById('uk-map'), UK_BOUNDS, lastUK, lastBase,
          {showCivDots:true,labelCiv:false,labelMil:true,maxLabels:70,grid:56}, PINS);
        drawContacts(document.getElementById('ne-canvas'), document.getElementById('ne-map'), NE_BOUNDS, lastNE, lastBase,
          {showCivDots:true,labelCiv:true,labelMil:true,maxLabels:40,grid:44}, PINS);
      }

      // start after load so main.js likely initialized socket
      window.addEventListener('load', bindPinSocket);

      // Minimal debug helper to verify rendering without backend
      window.debugAddPin = function(lat, lon, label, description){
        if (typeof lat !== 'number' || typeof lon !== 'number') return false;
        PINS.push({lat:lat, lon:lon, label:label||'', description:description||'', ts:Date.now()});
        redraw();
        return true;
      };
      })();
  </script>

  <script>
    // Interactive UK calibration using two clicks: London then Glasgow
    (function(){
      var ukCanvas = document.getElementById('uk-canvas');
      var UK_LON1 = -0.1278, UK_LAT1 = 51.5074; // London
      var UK_LON2 = -4.2518, UK_LAT2 = 55.8642; // Glasgow
      var step = 0; // 0 idle, 1 expect London, 2 expect Glasgow
      var p1=null, p2=null;

      // Local Mercator helper (scoped here to avoid cross-file issues)
      function mercYCal(lat){
        var rad = lat * Math.PI / 180;
        return Math.log(Math.tan((Math.PI/4) + (rad/2)));
      }

      function begin(){
        step = 1; p1 = p2 = null;
        console.info('[UK CAL] Click London on the UK map (green label)');
        ukCanvas.style.cursor = 'crosshair';
        window.addEventListener('click', onClick, true);
      }

      function onClick(ev){
        if(ev.target !== ukCanvas) return;
        var r = ukCanvas.getBoundingClientRect();
        var x = ev.clientX - r.left;
        var y = ev.clientY - r.top;
        var W = Math.max(1, Math.floor(r.width));
        var H = Math.max(1, Math.floor(r.height));
        if(step === 1){
          p1 = { xN: x/W, yN: y/H };
          step = 2;
          console.info('[UK CAL] Got London. Now click Glasgow.');
        } else if(step === 2){
          p2 = { xN: x/W, yN: y/H };
          finalize(W,H);
        }
        ev.preventDefault(); ev.stopPropagation();
      }

      function finalize(W,H){
        window.removeEventListener('click', onClick, true);
        ukCanvas.style.cursor = '';
        if(!p1 || !p2){ step=0; return; }
        var my1 = mercYCal(UK_LAT1), my2 = mercYCal(UK_LAT2);
        // Solve normalized linear maps
        var axn = (p2.xN - p1.xN) / (UK_LON2 - UK_LON1);
        var bxn = p1.xN - axn*UK_LON1;
        var ayn = (p2.yN - p1.yN) / (my2 - my1);
        var byn = p1.yN - ayn*my1;
        var cal = { axn: axn, bxn: bxn, ayn: ayn, byn: byn };
        localStorage.setItem('UK_CALN', JSON.stringify(cal));
        console.info('[UK CAL] Saved calibration:', cal);
        // Force redraw using new calibration
        if(window.dispatchEvent){ window.dispatchEvent(new Event('resize')); }
      }

      // Export helper
      window.calibrateUKInteractive = begin;
      window.clearUKCalibration = function(){ localStorage.removeItem('UK_CALN'); console.info('[UK CAL] Cleared.'); if(window.dispatchEvent){window.dispatchEvent(new Event('resize'));} };
    })();
  </script>

  <script>
    // Interactive NE calibration using two clicks: Newcastle then Whitby
    (function(){
      var neCanvas = document.getElementById('ne-canvas');
      var NE_LON1 = -1.6139, NE_LAT1 = 54.9733; // Newcastle upon Tyne
      var NE_LON2 = -0.6132, NE_LAT2 = 54.4863; // Whitby
      var step = 0;
      var p1=null, p2=null;

      function mercYCal(lat){ var rad = lat * Math.PI / 180; return Math.log(Math.tan((Math.PI/4) + (rad/2))); }

      function begin(){
        step = 1; p1 = p2 = null;
        console.info('[NE CAL] Click Newcastle on the NE map (green label)');
        neCanvas.style.cursor = 'crosshair';
        window.addEventListener('click', onClick, true);
      }

      function onClick(ev){
        if(ev.target !== neCanvas) return;
        var r = neCanvas.getBoundingClientRect();
        var x = ev.clientX - r.left;
        var y = ev.clientY - r.top;
        var W = Math.max(1, Math.floor(r.width));
        var H = Math.max(1, Math.floor(r.height));
        if(step === 1){
          p1 = { xN: x/W, yN: y/H };
          step = 2;
          console.info('[NE CAL] Got Newcastle. Now click Whitby.');
        } else if(step === 2){
          p2 = { xN: x/W, yN: y/H };
          finalize(W,H);
        }
        ev.preventDefault(); ev.stopPropagation();
      }

      function finalize(W,H){
        window.removeEventListener('click', onClick, true);
        neCanvas.style.cursor = '';
        if(!p1 || !p2){ step=0; return; }
        var my1 = mercYCal(NE_LAT1), my2 = mercYCal(NE_LAT2);
        var axn = (p2.xN - p1.xN) / (NE_LON2 - NE_LON1);
        var bxn = p1.xN - axn*NE_LON1;
        var ayn = (p2.yN - p1.yN) / (my2 - my1);
        var byn = p1.yN - ayn*my1;
        var cal = { axn: axn, bxn: bxn, ayn: ayn, byn: byn };
        localStorage.setItem('NE_CALN', JSON.stringify(cal));
        console.info('[NE CAL] Saved calibration:', cal);
        if(window.dispatchEvent){ window.dispatchEvent(new Event('resize')); }
      }

      window.calibrateNEInteractive = begin;
      window.clearNECalibration = function(){ localStorage.removeItem('NE_CALN'); console.info('[NE CAL] Cleared.'); if(window.dispatchEvent){window.dispatchEvent(new Event('resize'));} };
    })();
  </script>

  <!-- your orb scene -->
  <script src="/main.js"></script>
</body>
</html>
